"""
Darwin v4 — Protocols (abstract contracts).
Layer 0. Depends only on interfaces.types + interfaces.enums.
"""
from __future__ import annotations
from typing import Any, Dict, List, Optional, Protocol, Sequence, runtime_checkable

from darwin_agent.interfaces.enums import ExchangeID, OrderSide, StrategyID, TimeFrame
from darwin_agent.interfaces.types import (
    AgentEvalData, AgentMetrics, AllocationSlice, BalanceSnapshot, Candle, DNAData,
    ExchangeStatus, GenerationSnapshot, OrderRequest, OrderResult,
    PhaseParams, PortfolioRiskMetrics, Position, RiskVerdict,
    Signal, Ticker, TradeResult,
)


# ── Exchange adapter ─────────────────────────────────────────

@runtime_checkable
class IExchangeAdapter(Protocol):
    exchange_id: ExchangeID
    async def get_candles(self, symbol: str, timeframe: TimeFrame, limit: int = 100) -> List[Candle]: ...
    async def get_ticker(self, symbol: str) -> Ticker: ...
    async def get_positions(self) -> List[Position]: ...
    async def place_order(self, request: OrderRequest) -> OrderResult: ...
    async def close_position(self, symbol: str, side: OrderSide) -> OrderResult: ...
    async def set_leverage(self, symbol: str, leverage: int) -> bool: ...
    async def get_balance(self) -> float: ...
    async def get_status(self) -> ExchangeStatus: ...


# ── Exchange router ──────────────────────────────────────────

@runtime_checkable
class IExchangeRouter(Protocol):
    """Routes orders to the best exchange. Conforms to IExchangeAdapter."""
    async def get_candles(self, symbol: str, timeframe: TimeFrame, limit: int = 100) -> List[Candle]: ...
    async def get_ticker(self, symbol: str) -> Ticker: ...
    async def get_positions(self) -> List[Position]: ...
    async def place_order(self, request: OrderRequest) -> OrderResult: ...
    async def close_position(self, symbol: str, side: OrderSide) -> OrderResult: ...
    async def set_leverage(self, symbol: str, leverage: int) -> bool: ...
    async def get_balance(self) -> float: ...
    def get_exchange_statuses(self) -> Dict[ExchangeID, ExchangeStatus]: ...


# ── Strategy ─────────────────────────────────────────────────

@runtime_checkable
class IStrategy(Protocol):
    strategy_id: StrategyID
    def analyze(self, symbol: str, candles: Sequence[Candle], features: Sequence[float]) -> Optional[Signal]: ...


# ── Portfolio risk engine ────────────────────────────────────

@runtime_checkable
class IPortfolioRiskEngine(Protocol):
    """
    Portfolio-level risk independent of any single agent.
    State machine: NORMAL → DEFENSIVE → CRITICAL → HALTED.
    """
    def approve_order(self, signal: Signal, positions: List[Position], capital: float, phase_params: PhaseParams) -> RiskVerdict: ...
    def update_after_trade(self, result: TradeResult) -> None: ...
    def update_equity(self, equity: float) -> None: ...
    def update_positions(self, positions: List[Position]) -> None: ...
    def get_portfolio_state(self) -> PortfolioRiskMetrics: ...
    def get_sharpe_ratio(self) -> float: ...
    def get_max_drawdown_pct(self) -> float: ...
    def reset(self) -> None: ...


# ── Risk gate (agent-level, delegates to portfolio engine) ───
# IRiskGate kept for backward compat with DarwinAgent

@runtime_checkable
class IRiskGate(Protocol):
    def approve(self, signal: Signal, positions: List[Position], capital: float, phase_params: PhaseParams) -> RiskVerdict: ...
    def record_trade_result(self, result: TradeResult) -> None: ...
    def get_sharpe_ratio(self) -> float: ...
    def get_max_drawdown_pct(self) -> float: ...


# ── Position sizer ───────────────────────────────────────────

@runtime_checkable
class IPositionSizer(Protocol):
    def calculate(self, signal: Signal, capital: float, current_price: float, phase_params: PhaseParams) -> float: ...


# ── Feature engine ───────────────────────────────────────────

@runtime_checkable
class IFeatureEngine(Protocol):
    def extract(self, candles: Sequence[Candle]) -> List[float]: ...


# ── Strategy selector ────────────────────────────────────────

@runtime_checkable
class IStrategySelector(Protocol):
    def select(self, features: Sequence[float]) -> StrategyID: ...
    def update(self, strategy: StrategyID, reward: float) -> None: ...
    def get_weights(self) -> Dict[StrategyID, float]: ...


# ── Ledger ───────────────────────────────────────────────────

@runtime_checkable
class ILedger(Protocol):
    def get_balance(self, agent_id: str) -> BalanceSnapshot: ...
    def get_total_balance(self) -> BalanceSnapshot: ...


# ── Capital allocator ────────────────────────────────────────

@runtime_checkable
class ICapitalAllocator(Protocol):
    def allocate(self, agent_ids: List[str], total_capital: float, agent_fitness: Dict[str, float]) -> Dict[str, AllocationSlice]: ...
    def get_phase_params(self, capital: float) -> PhaseParams: ...


# ── Event bus ────────────────────────────────────────────────

@runtime_checkable
class IEventBus(Protocol):
    async def emit(self, event) -> None: ...
    def subscribe(self, event_type, handler) -> None: ...


# ── Persistence (Repository pattern) ────────────────────────

@runtime_checkable
class ITradeRepository(Protocol):
    """Persists trade results to Postgres."""
    async def save_trade(self, trade: TradeResult) -> None: ...
    async def get_trades(self, agent_id: str, limit: int = 100) -> List[TradeResult]: ...
    async def get_all_trades(self, limit: int = 500) -> List[TradeResult]: ...
    async def get_trades_since(self, since, limit: int = 500) -> List[TradeResult]: ...


@runtime_checkable
class IAgentRepository(Protocol):
    """Persists agent state and metrics to Postgres."""
    async def save_agent_metrics(self, metrics: AgentMetrics) -> None: ...
    async def save_agent_death(self, agent_id: str, generation: int, cause: str, metrics: AgentMetrics) -> None: ...
    async def get_agent_history(self, agent_id: str) -> List[AgentMetrics]: ...
    async def get_generation_agents(self, generation: int) -> List[AgentMetrics]: ...


@runtime_checkable
class IGenerationRepository(Protocol):
    """Persists generation snapshots to Postgres."""
    async def save_snapshot(self, snapshot: GenerationSnapshot) -> None: ...
    async def get_snapshot(self, generation: int) -> Optional[GenerationSnapshot]: ...
    async def get_all_snapshots(self, limit: int = 100) -> List[GenerationSnapshot]: ...
    async def get_latest_snapshot(self) -> Optional[GenerationSnapshot]: ...


@runtime_checkable
class IDNARepository(Protocol):
    """Persists DNA data (genomes) to Postgres."""
    async def save_dna(self, dna: DNAData) -> None: ...
    async def get_dna(self, dna_id: str) -> Optional[DNAData]: ...
    async def get_hall_of_fame(self, limit: int = 10) -> List[DNAData]: ...
    async def get_generation_dna(self, generation: int) -> List[DNAData]: ...


# ── Cache ────────────────────────────────────────────────────

@runtime_checkable
class ICache(Protocol):
    """Real-time cache layer (Redis)."""
    async def get(self, key: str) -> Optional[str]: ...
    async def set(self, key: str, value: str, ttl_seconds: int = 300) -> None: ...
    async def delete(self, key: str) -> None: ...
    async def get_json(self, key: str) -> Optional[Dict]: ...
    async def set_json(self, key: str, value: Dict, ttl_seconds: int = 300) -> None: ...
    async def publish(self, channel: str, message: str) -> None: ...
    async def exists(self, key: str) -> bool: ...


# ── Evolution engine ────────────────────────────────────────

@runtime_checkable
class IEvolutionEngine(Protocol):
    """Multi-agent evolutionary engine with ranking and elimination."""
    async def evaluate_generation(
        self,
        agents: List[AgentEvalData],
        portfolio_snapshot: Optional[PortfolioRiskMetrics] = None,
    ) -> GenerationSnapshot: ...
    def select_survivors(self, rankings: List[AgentMetrics], survival_rate: float) -> List[str]: ...
    def breed(self, parent_a: DNAData, parent_b: DNAData) -> DNAData: ...
    def mutate(self, dna: DNAData, mutation_rate: float) -> DNAData: ...
    def get_generation(self) -> int: ...
